#!/usr/bin/perl
# vim: ts=2 sw=2 ft=perl
eval 'exec perl -x -wS $0 ${1+"$@"}'
  if 0;
$|++;
use lib "lib";
use common::sense;
use autodie;
use Nobody::Util;   # exports path
use Carp::Always;
use Nobody::PP;
use TsvFile;
our(@VERSION) = qw( 0 1 0 );
sub main (@) {
  # Move to project root: path(__FILE__)->parent->parent
  my $root = path(__FILE__)->absolute->parent->parent;
  say "root: $root";
  chdir $root or die "Cannot chdir to project root $root: $!";

  my $src_dir = path('src');
  my $img_dir = path('img');
  my $tsv_dir = path('tsv');

  # Ensure directories exist
  $src_dir->is_dir or die "$src_dir directory not found at $src_dir";
  $img_dir->mkpath;
  $tsv_dir->mkpath;

  my @args = @_;
  my @pdfs;

  # No args: process all PDFs in src/
  @pdfs = sort $src_dir->children(qr/\.pdf$/i);
  eex( { pdfs=>\@pdfs } );
  die "No PDFs found in src/\n" unless @pdfs;
  my (%pid);
  for my $pdf_path (@pdfs) {
    eex( { pdf_path=>\$pdf_path } );
    unless ($pdf_path->is_file) {
      warn "Skipping '$pdf_path': not a regular file\n";
      next;
    }
    process_pdf($pdf_path, $img_dir, $tsv_dir);
  }
  for(keys %pid){
    $pid{$pid{$_}}=$_;
  };
  while(scalar(%pid)){
    ddx(\%pid);
    my ($pid)=waitpid(0,0);
    say $pid;
    delete $pid{$pid{$pid}};
    delete $pid{$pid};
  };
}

# Run an external command, and if it died due to SIGINT, bail out immediately.
sub run_cmd_or_die_on_sigint {
  my(@cmd)=@_;
  return system @cmd or die "system: @cmd: $?";

    if ($? == -1) {
        warn "failed to execute @cmd: $!\n";
        return $?;
    }

    if ($? & 127) {
      die "Command '@cmd' died with signal\n";
    } elsif (my $exit = $? >> 8) {
      # Non-zero exit status, but not SIGINT â€“ treat as a normal failure.
      die "Command '@cmd' exited with status $exit\n";
    }

    return $?;
}

sub process_pdf {
    my ($pdf_path, $img_dir, $tsv_dir) = @_;

    my $pdf  = $pdf_path->stringify;
    my $base = $pdf_path->basename('.pdf').'-';

    print STDERR "==> Processing $pdf\n";

    my $page_count = get_page_count($pdf);
    unless (defined $page_count && $page_count > 0) {
        die "Could not determine page count for '$pdf', skipping.\n";
        return;
    }

    my $last_page = $page_count;
    $last_page = $page_count if $last_page < 1;

    print STDERR "    Pages: $page_count (using 1..$last_page)\n";

    # 1. Render selected pages to PNG (document-at-a-time)
    my $img_prefix = $img_dir->child($base)->stringify;
    my(@list) = glob("$img_prefix*.png");
    eex( {pre=>$img_prefix,list=>\@list });
    for(@list) {
      s{[.]png$}{};
    };
    my @cmd = (
        'pdftoppm',
        '-png',
        '-r', 300,
        '-f', 1,
        '-l', $last_page,
        $pdf,
        $img_prefix,
    );
    print STDERR "    Running: @cmd\n";
    system(@cmd);
    die "@cmd: $?" if $?;

    # 2. Build page_number -> PNG path map, handling zero-padding
    my %png_for_page;
    for my $png ($img_dir->children(qr/^\Q$base\E-\d+\.png$/)) {
        my $name = $png->basename;
        next unless $name =~ /^\Q$base\E-(\d+)\.png$/;
        my $pageno = int($1);  # '01' -> 1, '10' -> 10, etc.
        $png_for_page{$pageno} = $png;
    }

    # 3. For each expected page, run tesseract -> TSV
    for my $page (1 .. $last_page) {
        my $png = $png_for_page{$page};

        unless ($png && $png->is_file) {
            warn "    Missing PNG for $pdf page $page (expected $base-<n>.png)\n";
            next;
        }

        my $tsv_prefix = $tsv_dir->child("$base-$page")->stringify;
        my $tsv_file   = $tsv_prefix . '.tsv';

        # Skip if TSV already exists; comment this out if you want to re-run
        if (-f $tsv_file) {
            print STDERR "    [exists] $tsv_file\n";
            next;
        }

        my @tcmd = (
            'tesseract',
            $png->stringify,
            $tsv_prefix,
            '-l', 'eng',
            'tsv',
        );
        print STDERR "    tesseract page $page -> $tsv_file\n";
run_cmd_or_die_on_sigint(@tcmd);
    }
}

sub get_page_count {
  my ($pdf) = @_;

  my @cmd = ('pdfinfo', $pdf);
  my $info = qx/@cmd 2>&1/;
  if ($? != 0) {
    warn "pdfinfo failed on '$pdf': $info";
    return undef;
  }

  my ($pages_line) = $info =~ /^Pages:\s+(\d+)/mi;
  return $pages_line ? int($pages_line) : undef;
}

# Pipeline driver entry point
main(@ARGV);
