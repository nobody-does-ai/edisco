#!/usr/bin/env perl
use strict;
use warnings;
use common::sense;
use Mail::IMAPClient;
use IO::Socket::SSL;
use Path::Tiny;
use POSIX qw(strftime);
use Digest::MD5 qw(md5_hex);

# Hard-coded Configuration
my $config = {
    imap_server  => 'imap.gmail.com',
    imap_port    => 993,
    download_dir => './mail',
    index_file   => './mail/message_ids.idx',
    target_label => '[Gmail]/All Mail',
};

# Setup Maildir structure
my $base_path = path($config->{download_dir});
my $dir = $base_path->child('dir');
$dir->child($_)->mkdir for qw(cur new tmp);

# Load credentials via pass
my ($user) = map { split m{\n} } qx(pass gmail.user);
my ($pass) = map { split m{\n} } qx(pass gmail.pass);
die "Credentials missing in pass" unless $user && $pass;

# Load global Message-ID index
# Value 0 = pre-existing, Value 1 = found/new in this session
my %global_seen;
if (-e $config->{index_file}) {
    %global_seen = map { $_ => 0 } path($config->{index_file})->lines({chomp => 1});
}

sub log_msg {
    printf("[%s] %s\n", strftime("%Y-%m-%d %H:%M:%S", localtime), shift);
}

# Connect to IMAP
my $socket = IO::Socket::SSL->new(
    PeerAddr => $config->{imap_server},
    PeerPort => $config->{imap_port},
) or die "SSL socket failed: $@";

my $imap = Mail::IMAPClient->new(
    Socket   => $socket,
    User     => $user,
    Password => $pass,
    Raw      => 1,
    Uid      => 1, 
) or die "IMAP connection failed: $@";

# SIMPLE TARGET LIST
my @targets = qw(
    lisaclaytonpaul@gmail.com
    johnbartletpaul@gmail.com
    @cmplaw.com
    @pollockinvestmentadvisors.com
    @washtenaw.org
);

eval {
    my $folder = $config->{target_label};
    log_msg("Selecting folder: $folder");
    $imap->select($folder) or die "Could not select $folder: $@";

    my %uids_to_check;
    log_msg("Starting individual term searches...");

    foreach my $term (@targets) {
        my $query = qq(TEXT "$term");
        my @results = $imap->search($query);
        log_msg(sprintf("Term [%s]: %d results", $term, scalar @results));
        $uids_to_check{$_} = 1 for @results;
    }

    my @all_uids = sort { $a <=> $b } keys %uids_to_check;
    log_msg(sprintf("Total unique UIDs to process: %d", scalar @all_uids));

    my $added = 0;
    my @newly_indexed;

    foreach my $uid (@all_uids) {
        my @mids = $imap->get_header($uid, "Message-ID");
        my $mid = $mids[0];
        
        if ($mid) {
            $mid =~ s/^\s*<//;
            $mid =~ s/>\s*$//;
            $mid =~ s/\s+$//;
        }
        
        next unless $mid;
        
        # If defined but 0, it was pre-existing. Skip.
        next if defined $global_seen{$mid};

        my $raw = $imap->message_string($uid);
        unless ($raw) {
            warn "Failed to fetch body for UID $uid ($mid): $@";
            next;
        }

        my $md5 = md5_hex($raw);
        my $target = $dir->child('cur', $md5);

        unless ($target->exists) {
            $target->spew_raw($raw);
            $added++;
        }

        # Mark as 1 (new in this session)
        $global_seen{$mid} = 1;
        push @newly_indexed, $mid;
        
        log_msg("Downloaded $added unique messages...") if $added > 0 && $added % 50 == 0;
    }

    if (@newly_indexed) {
        path($config->{index_file})->append(join("\n", @newly_indexed) . "\n");
    }

    log_msg("Sync complete. $added new unique messages downloaded.");
};

$imap->logout;
die "Fatal: $@\n" if $@;
