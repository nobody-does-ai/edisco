#!/usr/bin/env perl
use common::sense;
use DBI;
use lib ".";
use Path::Tiny qw(path);
use XML::LibXML::Simple qw(XMLin);
use JSON::MaybeXS;
use Nobody::Util;

# usage: sms_mms_to_raw.pl backup.xml
my $file = shift or die "Usage: $0 backup.xml\n";
my $abs  = path($file)->realpath->stringify;

my $json = JSON::MaybeXS->new(utf8 => 1, canonical => 1);

# Parse XML into Perl hashes/arrays
my $data = XMLin(
    $abs,
    KeepRoot   => 1,
    KeyAttr    => [],
    ForceArray => [qw( sms mms part addr parts addrs )],
);

my $root = $data->{smses}
  or die "Expected <smses> root\n";

# Helper to build a semi-stable source_id
sub sms_source_id {
    my ($msg, $idx) = @_;
    my $date    = $msg->{date}    // '';
    my $addr    = $msg->{address} // '';
    my $sub_id  = $msg->{sub_id}  // '';
    return join ':', 'sms', $date, $addr, $sub_id, $idx;
}

sub mms_source_id {
    my ($msg, $idx) = @_;
    my $date   = $msg->{date}   // '';
    my $tr_id  = $msg->{tr_id}  // '';
    my $m_type = $msg->{m_type} // '';
    return join ':', 'mms', $date, $tr_id, $m_type, $idx;
}

our($sms);
if($sms) {
if (my $sms_list = $root->{sms}) {
    for my $idx (0 .. $#$sms_list) {
        my $msg = $sms_list->[$idx] or next;
        my $src = sms_source_id($msg, $idx);
        my $j   = $json->encode($msg);
        ddx($msg);

    }
}
};
{
  use SMS::Renderer;
  our ($rend)=SMS::Renderer->new;
  sub render;
  our ($debug);
  *render=sub {
    $DB::single=1 if $debug//=1;
    my($obj)=shift;
    $rend->render($obj);
  };
}
# Import MMS
if (my $mms_list = $root->{mms}) {
    for my $idx (0 .. $#$mms_list) {
        my $msg = $mms_list->[$idx] or next;
        render($msg);
    }
}

say "Imported from $abs";
